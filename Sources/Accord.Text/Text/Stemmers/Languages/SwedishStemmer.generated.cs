// This file was generated automatically by the Snowball to C# compiler

#pragma warning disable 0164
#pragma warning disable 0162

namespace Accord.MachineLearning.Text.Stemmers
{
    using System;
    using System.Text;
    
    ///<summary>
    ///  This class was automatically generated by a Snowball to C# compiler 
    ///  It implements the stemming algorithm defined by a snowball script.
    ///</summary>
    /// 
    [System.CodeDom.Compiler.GeneratedCode("Snowball", "1.0.0")]
    public partial class SwedishStemmer : StemmerBase
    {
        private int I_x;
        private int I_p1;

        private static string g_v = "aeiouy\u00E4\u00E5\u00F6";
        private static string g_s_ending = "bcdfghjklmnoprtvy";
        private readonly Among[] a_0;
        private readonly Among[] a_1;
        private readonly Among[] a_2;

        /// <summary>
        ///   Initializes a new instance of the <see cref="SwedishStemmer"/> class.
        /// </summary>
        /// 
        public SwedishStemmer()
        {
            a_0 = new[] 
            {
                new Among("a", -1, 1),
                new Among("arna", 0, 1),
                new Among("erna", 0, 1),
                new Among("heterna", 2, 1),
                new Among("orna", 0, 1),
                new Among("ad", -1, 1),
                new Among("e", -1, 1),
                new Among("ade", 6, 1),
                new Among("ande", 6, 1),
                new Among("arne", 6, 1),
                new Among("are", 6, 1),
                new Among("aste", 6, 1),
                new Among("en", -1, 1),
                new Among("anden", 12, 1),
                new Among("aren", 12, 1),
                new Among("heten", 12, 1),
                new Among("ern", -1, 1),
                new Among("ar", -1, 1),
                new Among("er", -1, 1),
                new Among("heter", 18, 1),
                new Among("or", -1, 1),
                new Among("s", -1, 2),
                new Among("as", 21, 1),
                new Among("arnas", 22, 1),
                new Among("ernas", 22, 1),
                new Among("ornas", 22, 1),
                new Among("es", 21, 1),
                new Among("ades", 26, 1),
                new Among("andes", 26, 1),
                new Among("ens", 21, 1),
                new Among("arens", 29, 1),
                new Among("hetens", 29, 1),
                new Among("erns", 21, 1),
                new Among("at", -1, 1),
                new Among("andet", -1, 1),
                new Among("het", -1, 1),
                new Among("ast", -1, 1)
            };

            a_1 = new[] 
            {
                new Among("dd", -1, -1),
                new Among("gd", -1, -1),
                new Among("nn", -1, -1),
                new Among("dt", -1, -1),
                new Among("gt", -1, -1),
                new Among("kt", -1, -1),
                new Among("tt", -1, -1)
            };

            a_2 = new[] 
            {
                new Among("ig", -1, 1),
                new Among("lig", 0, 1),
                new Among("els", -1, 1),
                new Among("fullt", -1, 3),
                new Among("l\u00F6st", -1, 2)
            };

        }



        private int r_mark_regions()
        {
            // (, line 26
            I_p1 = limit;
            // test, line 29
            {
                int c1 = cursor;
                // (, line 29
                // hop, line 29
                {
                    int ret = cursor + 3;
                    if (0 > ret || ret > limit)
                    {
                        return 0;
                    }
                    cursor = ret;
                }
                // setmark x, line 29
                I_x = cursor;
                cursor = c1;
            }
            if (out_grouping(g_v, 97, 246, true) < 0)
            {
                return 0;
            }
 /* goto */            {
                /* gopast */ 
                int ret = in_grouping(g_v, 97, 246, true);
                if (ret < 0)
                {
                    return 0;
                }

                cursor += ret;
            }
            // setmark p1, line 30
            I_p1 = cursor;
            // try, line 31
            // (, line 31
            if (!(I_p1 < I_x))
            {
                goto lab0;
            }
            I_p1 = I_x;
        lab0: ; 

            return 1;
        }

        private int r_main_suffix()
        {
            int among_var;
            // (, line 36
            // setlimit, line 37
            int c1 = limit - cursor;
            // tomark, line 37
            if (cursor < I_p1)
            {
                return 0;
            }
            cursor = I_p1;
            int c2 = limit_backward;
            limit_backward = cursor;
            cursor = limit - c1;
            // (, line 37
            // [, line 37
            ket = cursor;
            // substring, line 37
            among_var = find_among_b(a_0);
            if (among_var == 0)
            {
                {
                    limit_backward = c2;
                    return 0;
                }
            }
            // ], line 37
            bra = cursor;
            limit_backward = c2;
            switch (among_var) 
            {
                case 0:
                    {
                        return 0;
                    }
                case 1:
                    // (, line 44
                    // delete, line 44
                    slice_del();
                    break;
                case 2:
                    // (, line 46
                    if (in_grouping_b(g_s_ending, 98, 121, false) != 0)
                    {
                        return 0;
                    }
                    // delete, line 46
                    slice_del();
                    break;
            }

            return 1;
        }

        private int r_consonant_pair()
        {
            // setlimit, line 50
            int c1 = limit - cursor;
            // tomark, line 50
            if (cursor < I_p1)
            {
                return 0;
            }
            cursor = I_p1;
            int c2 = limit_backward;
            limit_backward = cursor;
            cursor = limit - c1;
            // (, line 50
            // and, line 52
            int c3 = limit - cursor;
            // among, line 51
            if (find_among_b(a_1) == 0)
            {
                {
                    limit_backward = c2;
                    return 0;
                }
            }
            cursor = limit - c3;
            // (, line 52
            // [, line 52
            ket = cursor;
            // next, line 52
            if (cursor <= limit_backward)
            {
                {
                    limit_backward = c2;
                    return 0;
                }
            }
            cursor--;
            // ], line 52
            bra = cursor;
            // delete, line 52
            slice_del();
            limit_backward = c2;

            return 1;
        }

        private int r_other_suffix()
        {
            int among_var;
            // setlimit, line 55
            int c1 = limit - cursor;
            // tomark, line 55
            if (cursor < I_p1)
            {
                return 0;
            }
            cursor = I_p1;
            int c2 = limit_backward;
            limit_backward = cursor;
            cursor = limit - c1;
            // (, line 55
            // [, line 56
            ket = cursor;
            // substring, line 56
            among_var = find_among_b(a_2);
            if (among_var == 0)
            {
                {
                    limit_backward = c2;
                    return 0;
                }
            }
            // ], line 56
            bra = cursor;
            switch (among_var) 
            {
                case 0:
                    {
                        {
                            limit_backward = c2;
                            return 0;
                        }
                    }
                case 1:
                    // (, line 57
                    // delete, line 57
                    slice_del();
                    break;
                case 2:
                    // (, line 58
                    // <-, line 58
                    slice_from("l\u00F6s");
                    break;
                case 3:
                    // (, line 59
                    // <-, line 59
                    slice_from("full");
                    break;
            }
            limit_backward = c2;

            return 1;
        }

        private int stem()
        {
            // (, line 64
            // do, line 66
            {
                int c1 = cursor;
                {
                    // call mark_regions, line 66
                    int ret = r_mark_regions();
                    if (ret == 0)
                        goto lab0;
                    else if (ret < 0)
                        return ret;
                }
            lab0: ; 
                cursor = c1;
            }
            // backwards, line 67
            limit_backward = cursor; cursor = limit;
            // (, line 67
            // do, line 68
            {
                int c2 = limit - cursor;
                {
                    // call main_suffix, line 68
                    int ret = r_main_suffix();
                    if (ret == 0)
                        goto lab1;
                    else if (ret < 0)
                        return ret;
                }
            lab1: ; 
                cursor = limit - c2;
            }
            // do, line 69
            {
                int c3 = limit - cursor;
                {
                    // call consonant_pair, line 69
                    int ret = r_consonant_pair();
                    if (ret == 0)
                        goto lab2;
                    else if (ret < 0)
                        return ret;
                }
            lab2: ; 
                cursor = limit - c3;
            }
            // do, line 70
            {
                int c4 = limit - cursor;
                {
                    // call other_suffix, line 70
                    int ret = r_other_suffix();
                    if (ret == 0)
                        goto lab3;
                    else if (ret < 0)
                        return ret;
                }
            lab3: ; 
                cursor = limit - c4;
            }
            cursor = limit_backward;

            return 1;
        }

        /// <summary>
        ///   Stems the buffer's contents.
        /// </summary>
        /// 
        protected override bool Process()
        {
            return this.stem() > 0;
        }

    }
}

